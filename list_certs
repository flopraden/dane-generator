#!/usr/bin/python
import os
import sys
import json
import time
import netaddr
import ConfigParser
import collections
import itertools
import subprocess

import config

services = set()

def render(data):
    print "HTTP/1.0 200 OK"
    print "Content-Type: text/plain; charset=utf-8"
    print "Content-Length: %d" % len(data)
    print "Connection: close"
    print ""
    print data
    print ""
    sys.stdout.flush()

def services_definition():
    services_params = {}
    conf = ConfigParser.ConfigParser()
    if not conf.read(os.path.join(config.CERT_BASE_PATH, 'services.ini')):
        return services_params
    for service in services.intersection(conf.sections()):
        params = dict(conf.items(service))
        ports = []
        for port in params.get("ports", "").split():
            try:
                ports.append(int(port.strip()))
            except ValueError:
                ports.append(port.strip())
        services_params[service] = {'transport': params.get("transport"), 'ports': ports}
    return services_params

def list_domains():
    domains = collections.defaultdict(
        lambda:collections.defaultdict(
            lambda:{
                'services': set(),
                'certs': set()
            }
        )
    )
    dir = os.listdir(config.CERT_BASE_PATH)
    for domain in dir:
        if domain not in ["Archive"]:
            domains = list_certs(domains, domain)

    for domain in domains:
        for key, value in domains[domain].items():
            domains[domain][key] = {'services': list(value['services']), 'certs': list(value['certs'])}
    return domains

def list_certs(domains, domain):
    base_path = os.path.join(config.CERT_BASE_PATH, domain)
    if not os.path.isdir(base_path):
        return domains
    dir = os.listdir(base_path)
    dir.sort()
    for elt in dir:
        if elt in ["wildcard"]:
            continue
        elif elt == "Main":
            dn = domain
        else:
            dn = "%s.%s" % (elt, domain)

        elt_path = os.path.join(base_path, elt)
        cert_path = os.path.join(elt_path, 'ssl.crt')
        cert_path_new = os.path.join(elt_path, 'ssl.crt.new')
        cert_path_old = os.path.join(elt_path, 'ssl.crt.old')
        services_path = os.path.join(elt_path, 'services')
        alias_path = os.path.join(elt_path, 'alias')

        alias = [(dn, domain)]
        if os.path.isfile(alias_path):
            with open(alias_path) as f:
                for line in iter(f.readline, ""):
                   elt = line.strip()
                   if len(elt)>1 and elt[-1] == '.':
                       elt = elt[:-1]
                       domain = find_domain(elt)
                       alias.append((elt, domain))
                   elif elt and not elt[-1] == '.':
                       alias.append(("%s.%s" % (elt, domain), domain))
                   else:
                       raise ValueError("Alias %s not recognized" % elt)

        for dn, domain in alias:
            if (
                os.path.isfile(cert_path_old) and
                (time.time() - os.path.getmtime(cert_path_old)) < (3600 * 24 * 30)
            ):
                with open(cert_path_old) as f:
                    domains[domain][dn]['certs'].add(f.read())
            for path in [cert_path, cert_path_new]:
                if os.path.isfile(path):
                    with open(path) as f:
                        domains[domain][dn]['certs'].add(f.read())
            if os.path.isfile(services_path):
                with open(services_path) as f:
                    for line in iter(f.readline, ""):
                        domains[domain][dn]['services'].add(line.strip())
                        services.add(line.strip())
    return domains

def read_request():
    try:
        method, param, version = sys.stdin.readline().split()
    except ValueError:
        raise ValueError("forbidden")
    return method, param, version

def read_header():
    headers = {}
    for line in itertools.takewhile(lambda x:bool(x.strip()), iter(sys.stdin.readline, "\r\n")):
        line = line.strip()
        try:
            key, value = line.split(':', 1)
        except ValueError:
            raise ValueError("bad header")
        headers[key.strip()] = value.strip()
    return headers

def render_error(error):
    msg = "%s" % error
    print "HTTP/1.0 500 ERROR"
    print "Content-Type: text/plain; charset=utf-8"
    print "Content-Length: %d" % len(msg)
    print "Connection: close"
    print ""
    print msg
    print ""
    sys.stdout.flush()


def find_local_part(fqdn, domain):
    dn = fqdn[:-len(domain)-1]
    return dn

def find_domain(fqdn):
    fqdn = fqdn.split('.')
    for i in range(len(fqdn)):
        domain = ".".join(fqdn[i:])
        if domain in config.DOMAINS:
            return domain
    raise ValueError("domain not found for %s" % fqdn)

def list_sshkey():
    certs = collections.defaultdict(lambda:collections.defaultdict(list))
    if os.path.isdir(config.SSH_KEYS):
        dir = os.listdir(config.SSH_KEYS)
        for elt in dir:
            if elt.endswith(".pub"):
                with open(os.path.join(config.SSH_KEYS, elt)) as f:
                    fqdn = gethostname()
                    domain = find_domain(fqdn)
                    certs[domain][fqdn].append(f.read().strip())
    return certs

def gethostname():
    p = subprocess.Popen(["/bin/hostname", "-f"], stdout=subprocess.PIPE)
    return p.communicate()[0].strip()

if __name__ == '__main__':
    try:
        method, param, version = read_request()
        headers = read_header()

        domains = list_domains()
        services = services_definition()
        data = (services, domains, list_sshkey())
        render(json.dumps(data, indent=4))
    except Exception as error:
        render_error(error)
