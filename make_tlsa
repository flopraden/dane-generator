#!/usr/bin/python
import os
import sys
import ssl
import binascii
import hashlib
import urllib2
import json
import contextlib
import base64
import subprocess

import config

sshfp_algo = {
    "rsa" : 1,
    "dss" : 2,
    "ecdsa": 3,
    "ed25519": 4
}

def genSSHFP(hostname, cert):
    cert = cert.split()
    kind = cert[0]
    cert = cert[1]

    if hostname == "":
        hostname = "@"

    if kind.startswith("ssh-"):
        kind = kind[4:]
    elif kind.startswith("ecdsa-"):
        kind = "ecdsa"
    if kind in sshfp_algo:
        return '%s\tIN\tSSHFP %s %s %s' % (hostname, sshfp_algo[kind], 2, hashlib.sha256(base64.b64decode(cert)).hexdigest())

# reftype: 0 = plain cert, 1 = sha256, 2 = sha512
# certytype: 0 = CA pinning, 1 = cert pinning, 2 = self trusted CA, 3 = self trusted cert
# selector: 0 = full cert, 1 = SubjectPublicKeyInfo

def genTLSA(hostname, pemcert, port, proto, certtype=1, selector=0, reftype=1, compat=True):
    if not proto in ['tcp', 'udp']:
        raise ValueError("proto should be tcp or udp, nor %s" % proto)
    if not isinstance(port, int):
        raise ValueError("port should be int")
    # errors will be thrown already before we get here
    dercert = ssl.PEM_cert_to_DER_cert(pemcert)
    if not dercert:
        return

    if hostname:
        hostname = ".%s" % hostname

    if certtype not in [1, 3]:
        raise Exception("Only EE-cert supported right now")
    certhex = hashCert(reftype, dercert)
    if compat:
        # octet length is half of the string length; remember certtype and reftype are part of the length so +2
#        return "_443._tcp.%s IN TYPE65468 \# %s 0%s0%s%s"%(hostname, len(certhex)/2+2, certtype, reftype, certhex )
        return "_%s._%s%s\tIN\tTYPE52 \# %s 0%s0%s0%s%s"%(port, proto, hostname, len(certhex)/2 +3, certtype, selector, reftype, certhex)
    else:
        return "_%s._%s%s\tIN\tTLSA %s %s %s %s"%(port, proto, hostname, certtype, selector, reftype, certhex)

# take PEM encoded EE-cert and DER encode it, then sha256 it
def hashCert(reftype,certblob):
    if reftype == 0:
        return binascii.b2a_hex(certblob).upper()
    elif reftype == 1:
        hashobj = hashlib.sha256()
        hashobj.update(certblob)
    elif reftype == 2:
        hashobj = hashlib.sha512()
        hashobj.update(certblob)
    else:
        return 0
    return hashobj.hexdigest().upper()



def _generate_domain(data, domain):
    RRs = []
    services_definition = data[0]
    certificates = data[1].get(domain, {})
    for dn, params in certificates.items():
        for service in params["services"]:
            for port in services_definition[service]["ports"]:
                for cert in params["certs"]:
                    RRs.append(genTLSA(dn, cert, port, services_definition[service]["transport"], certtype=3, selector=0, reftype=2, compat=False))
    ssh_certificates = data[2].get(domain, {})
    for dn, certs in ssh_certificates.items():
        for cert in certs:
            sshfp_rr = genSSHFP(dn, cert)
            if sshfp_rr:
                RRs.append(sshfp_rr)
    return RRs


def generate_domain(domain):
    RRs = []
    for server in config.SERVERS:
        with contextlib.closing(urllib2.urlopen("http://%s:%s" % (server, config.PORT))) as f:
            data = json.loads(f.read())
            RRs.extend(_generate_domain(data, domain))
    RRs.sort()
    return "\n".join(RRs) + "\n"


def update_serial(domain):
    if config.UPDATE_SERIAL_SCRIPT:
        p = subprocess.Popen([config.UPDATE_SERIAL_SCRIPT, domain])
        code = p.wait()
        if code > 0:
            print "Serial of zone %s need to be updated" % domain
        else:
            print "Zone %s updated" % domain
    else:
        print "Serial of zone %s need to be updated" % domain


if __name__ == '__main__':
    servers = ["10.7.0.1", "10.7.0.2", "10.7.0.4"]
    bind_base_path = config.BIND_BASE_PATH
    for domain in config.DOMAINS:
        data = generate_domain(domain)
        with open("%s%s" % (bind_base_path, domain)) as f1:
            if f1.read() != data:
                with open("%s%s.new" % (bind_base_path, domain), 'w') as f2:
                    f2.write(data)
                os.rename("%s%s.new" % (bind_base_path, domain), "%s%s" % (bind_base_path, domain))
                update_serial(domain)

